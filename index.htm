<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Difference</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            display: flex; 
            min-height: 100vh; 
            background: #373B44;  /* fallback for old browsers */
background: -webkit-linear-gradient(to right, #4286f4, #373B44);  /* Chrome 10-25, Safari 5.1-6 */
background: linear-gradient(to right, #4286f4, #373B44); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
}
        
        #mainContainer { display: flex; width: 100%; height: calc(100vh - 60px); }
        
        #leftColumn { 
            flex: 2; 
            display: flex; 
            justify-content: center; 
            align-items: top; 
            padding: 20px; 
            flex-direction: column;
        }
        
        #rightColumn { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            padding: 20px; 
            gap: 15px; 
        }
        
        #webglCanvas { 
            border: 1px solid #2f0974;; 
            max-width: 100%; 
            max-height: 100%; 
        }
        
        #videoContainer { 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            height: 100%;
            justify-content: flex-start;
        }
        
        #webcamVideo { 
            width: 100%; 
            height: 33%; 
            border: 1px solid #2f0974; 
        }
        
        #grayscaleCanvas { 
            border: 1px solid #2f0974;; 
            width: 100%; 
            height: 33%; 
        }
        
        #detectionCanvas { 
            border: 1px solid #2f0974;; 
            width: 100%; 
            height: 33%; 
        }
        
        #footer { 
            box-sizing: border-box;
            position: fixed; 
            bottom: 0px; 
            z-index: 10; 
            color: #fff; 
            font-family: monospace; 
            border-top: 3px solid #2f0974;; 
            padding: 12px 16px; 
            width: 100%;
            height: 26px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            background: rgba(55, 59, 68, 0.9);
            backdrop-filter: blur(5px);
        }
        #controls { 
            position: relative; 
            z-index: 10; 
            color: #fff; 
            font-family: monospace; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        #parameters{
            padding-top: 5px;
            border-top: 1px solid #2f0974
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        <div id="leftColumn">
            <h1 style="color: #fff; text-align: center;">Webcam Difference Detection</h1>
            <canvas id="webglCanvas"></canvas>
            <div id="parameters">
                Delay: <input type="number" id="delayInput" value="1000">
            </div>
            
        </div>
        
        <div id="rightColumn">
            <div id="videoContainer">
                <video id="webcamVideo" autoplay playsinline></video>
                <canvas id="grayscaleCanvas"></canvas>
                <canvas id="detectionCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- Inserted: user-trigger (helps avoid some automatic permission issues) and a status area -->
    
    <div id="footer">
        <span>Demo Vision System for Demonstration</span>
        <button id="toggleFilterBtn">Switch Input Chain</button>
        <div id="controls">
            <button id="startBtn">Start Camera</button>
            <span id="status"></span>
        </div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        #version 300 es
        in vec4 a_position;
        in vec2 a_texCoord;
        out vec2 v_texCoord;

        void main() {
            gl_Position = a_position;
            v_texCoord = a_texCoord;
        }
    </script>

    <script id="copy-fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D u_image;
        in vec2 v_texCoord;
        out vec4 fragColor;

        void main() {
            fragColor = texture(u_image, v_texCoord);
        }
    </script>

    <script id="difference-fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D u_imageA; // Current frame
        uniform sampler2D u_imageB; // Previous frame
        in vec2 v_texCoord;
        out vec4 fragColor;

        void main() {
            vec4 colorA = texture(u_imageA, v_texCoord);
            vec4 colorB = texture(u_imageB, v_texCoord);

            // Calculate the absolute difference for each color channel (RGBA)
            // You might want to experiment with different difference metrics:
            // - abs(colorA.rgb - colorB.rgb) for just color, ignoring alpha
            // - length(colorA.rgb - colorB.rgb) for scalar magnitude
            float difference = dot(abs(colorA.rgb - colorB.rgb), vec3(0.2126, 0.7152, 0.0722));// for grayscale luminance difference
            //vec4 difference = abs(colorA - colorB);

            // Output the luminance difference as grayscale
            fragColor = vec4(vec3(difference), 1.0);
        }
    </script>

    <script id="grayscale-fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D u_image;
        in vec2 v_texCoord;
        out vec4 fragColor;

        void main() {
            vec4 color = texture(u_image, v_texCoord);
            
            // Convert to grayscale using luminance weights
            float gray = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
            
            // Output as grayscale
            fragColor = vec4(vec3(gray), 1.0);
        }
    </script>
    <script>
    /**
     * Adds a new fragment shader for Gaussian Laplacian of Gaussian (LoG) filtering.
     * This kernel will be used to filter the grayscale image.
     */
    const gaussianLogFragmentShaderSource = `#version 300 es
    precision mediump float;
    uniform sampler2D u_image;
    uniform vec2 u_texelSize;
    in vec2 v_texCoord;
    out vec4 fragColor;

    // 5x5 LoG kernel, sigma ~1.0
    const float kernel[25] = float[](
        0,   0,  -1,   0,  0,
        0,  -1,  -2,  -1,  0,
        -1,  -2,  16,  -2, -1,
        0,  -1,  -2,  -1,  0,
        0,   0,  -1,   0,  0
    );

    void main() {
        vec2 texOffset = u_texelSize; // 1.0 / texture size
        vec3 sum = vec3(0.0);
        int k = 0;
        for (int y = -2; y <= 2; ++y) {
           for (int x = -2; x <= 2; ++x) {
              vec2 offset = vec2(float(x), float(y)) * texOffset;
              vec3 color = texture(u_image, v_texCoord + offset).rgb;
              sum += color * kernel[k];
              k++;
           }
        }
        // Clamp to [0,1] for display
        float v = clamp(sum.r, 0.0, 1.0);
        fragColor = vec4(vec3(v), 1.0);
    }
    `;

    // You can now use `gaussianLogFragmentShaderSource` to create a WebGL shader program
    // and apply it to your grayscale image as needed.
    </script>

    <script id="laplacian-gaussian-fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        uniform sampler2D u_image;
        uniform vec2 u_resolution;
        in vec2 v_texCoord;
        out vec4 fragColor;

        void main() {
            vec2 onePixel = vec2(1.0) / u_resolution;
            
            // Laplacian of Gaussian (LoG) filter kernel
            // This is a 5x5 approximation of LoG
            float kernel[25];
            kernel[0] = 0.0; kernel[1] = 0.0; kernel[2] = -1.0; kernel[3] = 0.0; kernel[4] = 0.0;
            kernel[5] = 0.0; kernel[6] = -1.0; kernel[7] = -2.0; kernel[8] = -1.0; kernel[9] = 0.0;
            kernel[10] = -1.0; kernel[11] = -2.0; kernel[12] = 16.0; kernel[13] = -2.0; kernel[14] = -1.0;
            kernel[15] = 0.0; kernel[16] = -1.0; kernel[17] = -2.0; kernel[18] = -1.0; kernel[19] = 0.0;
            kernel[20] = 0.0; kernel[21] = 0.0; kernel[22] = -1.0; kernel[23] = 0.0; kernel[24] = 0.0;
            
            vec4 colorSum = vec4(0.0);
            
            for(int i = 0; i < 5; i++) {
                for(int j = 0; j < 5; j++) {
                    vec2 offset = vec2(float(i - 2), float(j - 2)) * onePixel;
                    vec4 color = texture(u_image, v_texCoord + offset);
                    colorSum += color * kernel[i * 5 + j];
                }
            }
            
            // Normalize and enhance the result
            colorSum = abs(colorSum);
            fragColor = vec4(colorSum.rgb, 1.0);
        }
    </script>

    <script src="script.js"></script>
</body>
</html>